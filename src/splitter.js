
// represents the 3 different types of codes that are generated. Each starts out with one of these values,
// which indicate with private key segments and which pad keys it embeds.
const PART_COMBINATIONS = [
    0x01,  // part 0 and 1
    0x02,  // part 1 and 2
    0x03   // part 0 and 2
];
// this will be incremented if the split method is changed
const SPLIT_METHOD_VERSION = 0;

const Splitter = function() {

  // define getRandomBytes so it works in Node as well as in browsers.
  const getRandomBytes = (
    (typeof self !== 'undefined' && (self.crypto || self.msCrypto))
      ? function() { // Browsers
          var crypto = (self.crypto || self.msCrypto), QUOTA = 65536;
          return function(n) {
            var a = new Uint8Array(n);
            for (var i = 0; i < n; i += QUOTA) {
              crypto.getRandomValues(a.subarray(i, i + Math.min(n - i, QUOTA)));
            }
            return a;
          };
        }
      : function() { // Node
          return require("crypto").randomBytes;
        }
  )();


  function decodeKey(keyparts, res, pads) {
      let parts = [];
      let part_combination = (res.partType & 0x0F);
      if (part_combination === PART_COMBINATIONS[0]) {
          // key type 1, contains part 1 and 2, encoded with pad key 1
          parts[0] = xor(res.part1, pads[0]);
          parts[1] = xor(res.part2, pads[0]);
      } else if (part_combination === PART_COMBINATIONS[1]) {
          // key type 2, contains part 2 and 3, encoded with pad key 2
          parts[1] = xor(res.part1, pads[1]);
          parts[2] = xor(res.part2, pads[1]);
      } else if (part_combination === PART_COMBINATIONS[2]) {
          // key type 3, contains part 1 and 3, encoded with pad key 3
          parts[0] = xor(res.part1, pads[2]);
          parts[2] = xor(res.part2, pads[2]);
      }
      // now compare any parts we found with the keyparts passed in. If the keyparts array already
      // contains elements they should match with what we found here
      for (let i = 0; i < 3; i++) {
          if (parts[i]) {
              if (keyparts[i] && bytesToHex(keyparts[i]) !== bytesToHex(parts[i])) {
                  throw new Error(`decrypted key parts in both codes do not match! ${bytesToHex(keyparts[i])} / ${bytesToHex(parts[i])}`);
              }
              keyparts[i] = parts[i];
          }
      }
  }

  // Convert a hex string to a byte array
  function hexToBytes(hex) {
      let bytes = new Uint8Array(hex.length/2);
      for (c = 0; c < hex.length/2; c += 1)
      bytes[c] = parseInt(hex.substr(c*2, 2), 16);
      return bytes;
  }

  // Convert a byte array to a hex string
  function bytesToHex(bytes) {
      for (var hex = [], i = 0; i < bytes.length; i++) {
          hex.push((bytes[i] >>> 4).toString(16));
          hex.push((bytes[i] & 0xF).toString(16));
      }
      return hex.join("");
  }

  /**
   * performs an xor operation on bytes of a given array. It will always return an array
   * with the same length of a, even if b (the xor filter) is longer
   *
   * @param a key to perform xor operation on
   * @param b the xor filter (one-time-pad)
   * @returns array
   */
  function xor(a, b) {
      return a.map((c, i) => {
          return a[i] ^ b[i];
      });
  }

  /**
   * for testing only, prints the object that extractCode() returns.
   * @param code
   */
  function printCode(code) {
      console.log("\nkeyType: " + code.partType);
      console.log("part 1: " + bytesToHex(code.part1));
      console.log("part 2: " + bytesToHex(code.part2));
      console.log("pad 1: " + bytesToHex(code.pad1));
      console.log("pad 2: " + bytesToHex(code.pad2));
  }


return {

    /**
     * Splits a private key (ie Ethereum or Bitcoin private key) and generate 3 separate codes out of them.
     * @param key private key (as a hex string)
     * @returns an array of 3 new keys, each as strong as the original one.
     */
    splitPrivateKey(key) {
        let {keySegments, keyLength} = this.splitInto3Segments(key);

        // generate 3 random One Time Pad keys, at the length of one third of the private key length
        let pads = this.createOTPKeys(keyLength);

        keys = [
            this.makeSplitKey(PART_COMBINATIONS[0], keySegments, keyLength, pads),
            this.makeSplitKey(PART_COMBINATIONS[1], keySegments, keyLength, pads),
            this.makeSplitKey(PART_COMBINATIONS[2], keySegments, keyLength, pads)
        ];
        return keys.map((k) => { return bytesToHex(k); });
    },

    toBytes(hexStr) {
      return hexToBytes(hexStr);
    },

    toHexStr(bytes) {
      return bytesToHex(bytes);
    },

    /**
     * restores the original private key using any 2 of the 3 keys generated by splitPrivateKey()
     * @param splitKey1 a buffer containing one of the split keys
     * @param splitKey2 a buffer containing one other split key
     * @returns the original private key
     */
    restorePrivateKey(splitKey1, splitKey2) {
        // convert to byte array if passed in as String
        if (typeof splitKey1 === 'string') {
          splitKey1 = hexToBytes(splitKey1);
          splitKey2 = hexToBytes(splitKey2);
        }

        let res1 = this.extractCode(splitKey1);
        //printCode(res1);

        let res2 = this.extractCode(splitKey2);
        //printCode(res2);

        let pads = this.retrievePads(res1, res2);

        let keySegments = [];
        decodeKey(keySegments, res1, pads);
        // console.log("after parting code 1:");
        // if (keyparts[0]) console.log("part 1: " + asHex(keyparts[0]));
        // if (keyparts[1]) console.log("part 2: " + asHex(keyparts[1]));
        // if (keyparts[2]) console.log("part 3: " + asHex(keyparts[2]));

        decodeKey(keySegments, res2, pads);
        // console.log("after parting code 2:");
        // if (keyparts[0]) console.log("part 1: " + asHex(keyparts[0]));
        // if (keyparts[1]) console.log("part 2: " + asHex(keyparts[1]));
        // if (keyparts[2]) console.log("part 3: " + asHex(keyparts[2]));

        return bytesToHex(keySegments[0]) + bytesToHex(keySegments[1]) + bytesToHex(keySegments[2]);
    },


    /***************************************************************************************************
     * all methods below should be considered private, but are exported anyway to make this class
     * better testable.
     ***************************************************************************************************/

    /**
     * generates 3 OTP keys of equal length, which are used to encrypt the key segments for each key type
     * @param length key length to use (typically 11, as 3x11 = 33 bytes, which fits an Ethereum private key)
     * @returns array of OTP keys (of type Buffer)
     */
    createOTPKeys(length) {
        let pads = [];
        for (let i = 0; i < 3; i++) {
            pads[i] = getRandomBytes(length);
            // console.log("created secret key " + asHex(pads[i]));
        }
        return pads;
    },

    /**
     * splits the private key into three seqments (almost) equal in size. For 32 byte Ethereum private keys, this will
     * return 3 buffers containing 11, 11 and 10 bytes.
     * @param key the private key (string) to split up
     */
    splitInto3Segments(key) {
        const bytes = hexToBytes(key);

        // we're going to split in 3 parts
        let start = 0, end = 0;
        let bufpart = [];
        let partLen = Math.round(bytes.length / 3);
        for (let i = 0; i < 3; i++) {
            if (i === 2) {
                // last element store the remainder
                end = bytes.length;
            } else {
                end = start + partLen;
            }
            bufpart[i] = bytes.slice(start, end);
            start = start + bufpart[i].length;
        }

        let keyLength = Math.max(partLen, bufpart[2].length); // this will typically be 11 for Ethereum private keys
        return {keySegments: bufpart, keyLength};
    },

    /**
     * constructs one of the three split keys, consisting of 2/3s of the key (encoded using OTP) and two pad keys.
     * The OTP key that the private key segment is encoded with, only exists in the other keys.
     * The keys are encoded as follows (using example of a 32 byte Ethereum private key)
     *
     * byte 1:      part type identifier (one of the PART_COMBINATIONS values)
     * byte 2:      length of the first key segment (encoded with OTP key)
     * byte 3-13:   first key segment
     * byte 14:     length of the second key segment (encoded with OTP key)
     * byte 15-25:  second key segment
     * byte 26:     length of the OTP keys used (11 for ethereum keys)
     * byte 27-37:  first OTP key
     * byte 38-48:  second OTP key
     *
     * @param partyType
     * @param keySegments  array contain all 3 key segments
     * @param keyLength    OTP key length (typically 11)
     * @param pads         array of 3 (11 byte) random OTP keys
     */
    makeSplitKey(partType, keySegments, keyLength, pads) {
        // generate 3 random keys to be used
        let buf = [(SPLIT_METHOD_VERSION << 4) + partType];
        let p1, p2, keys;
        if (partType === PART_COMBINATIONS[0]) {
            p1 = xor(keySegments[0], pads[0]);
            p2 = xor(keySegments[1], pads[0]);
            keys = [pads[1], pads[2]];   // add the other two ciphers, one of which will be needed to decrypt
        } else if (partType === PART_COMBINATIONS[1]) {
            p1 = xor(keySegments[1], pads[1]);
            p2 = xor(keySegments[2], pads[1]);
            keys = [pads[0], pads[2]];
        } else if (partType === PART_COMBINATIONS[2]) {
            p1 = xor(keySegments[0], pads[2]);
            p2 = xor(keySegments[2], pads[2]);
            keys = [pads[0], pads[1]];
        }
        buf.push(p1.length);
        buf.push(...p1);
        buf.push(p2.length);
        buf.push(...p2);
        buf.push(keyLength);
        buf.push(...keys[0]);
        buf.push(...keys[1]);

        return new Uint8Array(buf);
    },

    /**
     * accepts a buffer or array with a split key, and extracts the key segments and OTP keys from it
     * @param str
     * @returns object containing partType, part1, part2, pad1 and pad2 properties
     */
    extractCode(str) {
        //console.log((new Buffer(str, 'base64')))
        let res = {}, length;
        // move the data into a byte array
        let arr = str;
        res.partType = arr[0]; // should be one of the PART_COMBINATIONS values
        length = arr[1]; // length of the first key part
        let c = 2;
        res.part1 = arr.slice(c, c + length);
        c += length;
        length = arr[c]; // length of the second key part
        c += 1;
        res.part2 = arr.slice(c, c + length);
        let keylength = arr[c + length];
        c += length + 1;
        res.pad1 = arr.slice(c, c + keylength);
        c += keylength;
        res.pad2 = arr.slice(c, c + keylength);
        return res;
    },


    /**
     * retrieves the OTP keys from both split keys. There's 3 of them, but each split key only holds
     * 2. This function with return an array of pad key 1,2, and 3 in the right order.
     *
     *  a(key0)  b(key0)  key1  key2   TYPE 1
     *  b(key1)  c(key1)  key0  key2   TYPE 2
     *  a(key2)  c(key2)  key0  key1   TYPE 3
     */
    retrievePads(res1, res2) {
        let pads = [[], [], []];
        for (let res of [res1, res2]) {
            if (res.partType === PART_COMBINATIONS[0]) {
                // type 1 code contains pad 2 and pad 3
                pads[1].push(res.pad1);
                pads[2].push(res.pad2);
            } else if (res.partType === PART_COMBINATIONS[1]) {
                // type 2 code contains pad 1 and pad 3
                pads[0].push(res.pad1);
                pads[2].push(res.pad2);
            } else if (res.partType === PART_COMBINATIONS[2]) {
                // type 3 code contains pad 1 and pad 2
                pads[0].push(res.pad1);
                pads[1].push(res.pad2);
            }
        }

        // check that if we extracted the same key multiple times, they must match. If not,
        // one of the codes was read incorrectly or tampered with
        let p = pads.map((pad, i) => {
            if (pad.length === 0) {
                throw new Error(`no pad key data for pad ${i}`);
            } else if (pad.length === 2) {
                let p1 = bytesToHex(pad[0]);
                let p2 = bytesToHex(pad[1]);
                if (p1 !== p2) {
                    throw new Error(`pad ${i} exists in both codes but do not match! ${p1} / ${p2}`);
                }
            }
            return pad[0];
        });
        return p;
    }
  }
}




// export this module
if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {
    module.exports = Splitter;
} else {
    if (typeof define === 'function' && define.amd) {
        define([], function() {
            return Splitter;
        });
    } else {
        window.Splitter = Splitter;
    }
}
