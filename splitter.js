const crypto = require('crypto');
const QRCode = require('qrcode');


// represents the 3 different types of codes that are generated. Each starts out with one of these values,
// which indicate with private key segments and which pad keys it embeds.
const PART_COMBINATIONS = [
  0x01,  // part 1 and 2
  0x12,  // part 2 and 3
  0x02   // part 1 and 3
];

/**
 * performs an xor operation on bytes of a given array. It will always return an array
 * with the same length of a, even if b (the xor filter) is longer
 *
 * @param a key to perform xor operation on
 * @param b the xor filter (one-time-pad)
 * @returns array
 */
function xor(a, b) {
  return a.map((c , i) => {
    return a[i] ^ b[i];
  });
}


class Splitter {

  /**
   * Splits a private key (ie Ethereum or Bitcoin private key) and generate 3 separate codes out of them.
   * @param key private key (as a hex string)
   * @returns an array of 3 new keys, each as strong as the original one.
   */
  splitPrivateKey(key) {
    let {keyParts, keyLength} = splitInto3Parts(key);

    let pads = [];
    for (let i=0; i<3; i++) {
      pads[i] = crypto.randomBytes(keyLength);
      // console.log("created secret key " + asHex(pads[i]));
    }

    return [
      constructKeys(PART_COMBINATIONS[0], keyParts, keyLength, pads),
      constructKeys(PART_COMBINATIONS[1], keyParts, keyLength, pads),
      constructKeys(PART_COMBINATIONS[2], keyParts, keyLength, pads)
    ];
  }

  /**
   * restores the original private key using any 2 of the 3 keys generated by splitPrivateKey()
   * @param code1
   * @param code2
   * @returns the original private key
   */
  restorePrivateKey(code1, code2) {

  }


  /***************************************************************************************************
   * all methods below should be considered private, but are exported anyway to make this class
   * better testable.
   ***************************************************************************************************/


  /**
   * splits the private key into three almost equal parts. For 32 byte Ethereum addresses, this will
   * return 3 buffers containing 11, 11 and 10 bytes.
   * @param key the private key (string) to split up
   */
  splitInto3Parts(key) {
    const buf = new Buffer(key, 'hex');

    // we're going to split in 3 parts
    let start=0, end=0;
    let bufpart = [];
    let partLen = Math.ceil(buf.length / 3);
    for (let i=0; i<3; i++) {
      if (i == 2) {
        // last element store the remainder
        end = buf.length;
      } else {
        end = start + partLen;
      }
      bufpart[i] = buf.slice(start, end);
      start = start + bufpart[i].length;
    }
    let keyLength = Math.max(partLen, bufpart[2].length); // this will typically be 11 for Ethereum private keys
    return { keyParts: bufpart, keyLength};
  }


}

module.exports = Splitter;




/**
 * creates a buffer containing the data for the barcode
 * @param keyType
 * @param keypart
 */
function constructKeys(partCombo, keypart, keyLength, ciphers) {
    // generate 3 random keys to be used
    let buf = [partCombo];
    let p1, p2, keys;
    if (partCombo === PART_COMBINATIONS[0] ) {
        p1 = xor(keypart[0], ciphers[0]);
        p2 = xor(keypart[1], ciphers[0]);
        keys = [ciphers[1],ciphers[2]];   // add the other two ciphers, one of which will be needed to decrypt
    } else if (partCombo === PART_COMBINATIONS[1] ) {
        p1 = xor(keypart[1], ciphers[1]);
        p2 = xor(keypart[2], ciphers[1]);
        keys = [ciphers[0],ciphers[2]];
    } else if (partCombo === PART_COMBINATIONS[2] ) {
        p1 = xor(keypart[0], ciphers[2]);
        p2 = xor(keypart[2], ciphers[2]);
        keys = [ciphers[0],ciphers[1]];
    }
    buf.push(p1.length);
    buf.push(...p1);
    buf.push(p2.length);
    buf.push(...p2);
    buf.push(keyLength);
    buf.push(...keys[0]);
    buf.push(...keys[1]);
    
    return new Buffer(buf);
}

function asHex(buf) {
  return buf ? (new Buffer(buf)).toString('hex') : '';
}





function createCodes(privateKey) {
}



function extractCode(str) {
    //console.log((new Buffer(str, 'base64')))
    let res = {}, length;
    // move the data into a byte array
    let arr = [...(new Buffer(str, 'base64'))];
    res.partType = arr[0]; // should be one of the PART_COMBINATIONS values
    length = arr[1]; // length of the first key part
    let c = 2;
    res.part1 = arr.slice(c, c+length);
    c += length;
    length = arr[c]; // length of the second key part
    c += 1;
    res.part2 = arr.slice(c, c+length);
    let keylength = arr[c+length];
    c += length + 1;
    res.pad1 = arr.slice(c, c+keylength);
    c += keylength;
    res.pad2 = arr.slice(c, c+keylength);
    return res;
}







/**
 *  a(key0)  b(key0)  key1  key2   TYPE 1
 *  b(key1)  c(key1)  key0  key2   TYPE 2
 *  a(key2)  c(key2)  key0  key1   TYPE 3
 *  
 */

/**
 * generates 3 QR codes from an encrypted private key. This private key can be decrypted
 * again with the password, and with 2 of the QR codes.
 * @param key array of data to put in QR Code
 * @param filename filename to store QR Code at
 */
function generateQrCode(str, filename, callback) {
  let options = {
    color: {
      dark: '#00F',  // Blue dots
      light: '#0000' // Transparent background
    },
    errorCorrectionLevel: 'M'
  };

  QRCode.toFile(filename, str, options, (err) => {
    if (err) throw err;
    if (callback) callback();
  });
}


function retrievePads(res1, res2) {
  let pad1 = [];
  let pad2 = [];
  let pad3 = [];
  for (res of [res1, res2]) {
    if (res.partType === PART_COMBINATIONS[0]) {
      // type 1 code contains pad 2 and pad 3
      pad2.push(res.pad1);
      pad3.push(res.pad2);
    } else if (res.partType === PART_COMBINATIONS[1]) {
      // type 2 code contains pad 1 and pad 3
      pad1.push(res.pad1);
      pad3.push(res.pad2);
    } else if (res.partType === PART_COMBINATIONS[2]) {
      // type 3 code contains pad 1 and pad 2
      pad1.push(res.pad1);
      pad2.push(res.pad2);
    }
  }

  // check that if we extracted the same key multiple times, they must match. If not one of the
  // codes was read incorrectly or tampered with
  let p1 = checkPad(pad1, 1);
  let p2 = checkPad(pad2, 2);
  let p3 = checkPad(pad3, 3);
  return [p1, p2, p3]
}

/**
 * we've collected the random pad keys from two cards. There will always be one key that's defined
 * on both cards. This function validates that they're the same. If not, the code was entered incorrectly
 * or tampered with.
 * @param pad array of one or two pad random keys that should be the same
 * @param number index number, for error messaging
 * @returns the pad key
 */
function checkPad(pad, number) {
  if (pad.length === 0) {
    throw new Error(`no pad key data for pad ${number}`);
  } else if (pad.length === 2) {
    let p1 = (new Buffer(pad[0]).toString('hex'));
    let p2 = (new Buffer(pad[1]).toString('hex'));
    if (p1 !== p2) {
      throw new Error(`pad ${number} exists in both codes but do not match! ${p1} / ${p2}`);
    }
  }
  return pad[0];
}

function printCode(code) {
  console.log("\nkeyType: " + code.partType);
  console.log("part 1: " + (new Buffer(code.part1)).toString('hex'));
  console.log("part 2: " + (new Buffer(code.part2)).toString('hex'));
  console.log("pad 1: " + (new Buffer(code.pad1)).toString('hex'));
  console.log("pad 2: " + (new Buffer(code.pad2)).toString('hex'));
}

function decodeKey(keyparts, res, pads)
{
  let parts = [];
  if (res.partType === PART_COMBINATIONS[0]) {
    // key type 1, contains part 1 and 2, encoded with pad key 1
    parts[0] = xor(res.part1, pads[0]);
    parts[1] = xor(res.part2, pads[0]);
  } else if (res.partType === PART_COMBINATIONS[1]) {
    // key type 2, contains part 2 and 3, encoded with pad key 2
    parts[1] = xor(res.part1, pads[1]);
    parts[2] = xor(res.part2, pads[1]);
  } else if (res.partType === PART_COMBINATIONS[2]) {
    // key type 3, contains part 1 and 3, encoded with pad key 3
    parts[0] = xor(res.part1, pads[2]);
    parts[2] = xor(res.part2, pads[2]);
  }
  // now compare any parts we found with the keyparts passed in. If the keyparts array already
  // contains elements they should match with what we found here
  for (let i=0; i<3; i++) {
    if (parts[i]) {
      if (keyparts[i] && asHex(keyparts[i]) !== asHex(parts[i])) {
        throw new Error(`decrypted key parts in both codes do not match! ${asHex(keyparts[i])} / ${asHex(parts[i])}`);
      }
      keyparts[i] = parts[i];
    }
  }
}

function restorePrivateKey(key1, key2) {
  let res1 = extractCode(key1);
  printCode(res1);

  let res2 = extractCode(key2);
  printCode(res2);

  let pads = retrievePads(res1, res2);

  let keyparts = [];
  decodeKey(keyparts, res1, pads);
  console.log("after parting code 1:");
  if (keyparts[0]) console.log("part 1: " + asHex(keyparts[0]));
  if (keyparts[1]) console.log("part 2: " + asHex(keyparts[1]));
  if (keyparts[2]) console.log("part 3: " + asHex(keyparts[2]));

  decodeKey(keyparts, res2, pads);
  console.log("after parting code 2:");
  if (keyparts[0]) console.log("part 1: " + asHex(keyparts[0]));
  if (keyparts[1]) console.log("part 2: " + asHex(keyparts[1]));
  if (keyparts[2]) console.log("part 3: " + asHex(keyparts[2]));

  return asHex(keyparts[0]) + asHex(keyparts[1]) + asHex(keyparts[2]);
}





/**
console.log("input key: " + key);

keys = createCodes(key);

for (let i=0; i<3; i++) {
    generateQrCode(keys[i].toString('base64'), `split_${i+1}.png`);
}


function testEncodeDecode(keys, i, j) {
  let fullKey = restorePrivateKey(keys[i], keys[j]);
  let match = (fullKey == key) ? "matches!" : "does not match!";
  console.log(`testing ${i} with ${j} ${match}`);
  if (fullKey !== key) {
    throw new Error("bug!");
  }
}



testEncodeDecode(keys, 0, 1);
testEncodeDecode(keys, 1, 0);

testEncodeDecode(keys, 0, 2);
testEncodeDecode(keys, 2, 0);

testEncodeDecode(keys, 1, 2);
testEncodeDecode(keys, 2, 1);
*/
